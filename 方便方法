目录
代码框架，代码块	5
检查表是否正确，一发现有不正确的就返回	5
'检查表格是否符合所有条件	6
1.第一个检查项目	6
检查常用手法	7
检查某顺序的几个（multiline）field是否存在于指定尺寸的range里，考不考虑field的顺序option	7
检查某顺序的几个field是否存在于某range里或某相同排列的arr里，考不考虑field的顺序option	8
CompareSingleDimentionArray检查字段是否缺失，缺失了哪些，多出了哪些，横向，纵向	8
比较两个数组的size（shape）	9
提供两个数组，获得第一个数组的元素相对于第二个数组的绝对序号	9
提供一个数组和一个range，获得第一个数组的元素相对于range的表格列号和相对数组的列号	9
获得某个横向或者纵向的单行或单列的field-row 或field-col的   rowindex或colIndex的字典	9
常规场景操作自动化	10
1.汇总框架	10
1.文件夹	11
文件夹是否存在	11
文件是否存在	11
文件夹不存在则创建CreateDir()	11
获取文件夹下文件列表	11
获取文件夹下某些文件格式列表	11
获取文件夹下子文件夹列表	11
获取文件夹和子文件夹下所有文件列表	11
获取文件夹和子文件夹下的某些文件格式列表	11
删除文件夹下文件-按文件列表删	11
删除文件夹下文件-按某些文件格式删	11
清空文件夹(删除再新建)	11
2.文件	11
文件路径	11
文件格式名	11
文件名称	11
文件短名带格式名	11
文件其他信息	11
3.	11
某表名表格是否存在	11
某些表名是否存在	11
提供表名数组，返回存在于工作簿的表名(实质是提供数组A和数组B，返回A存在于数组B的结果)	12
提供表名数组，返回不存在于工作簿的表名(实质是提供数组A和数组B，返回A不存在于数组B的结果)	12
数组元素相减（集合相减）？交集？	12
二维数组转一维	12
多行多列数组转单行单列数组	12
按表名数组创建新表（已存在的如何处理？）	13
按表名数组删除表（不存在的表名是否报错？）	13
表格位置排序	13
删除所有表除了某表名	13
删除所有表除了某表	13
删除所有表除了数组里的表名	13
删除所有表除了数组里的表（数组里不存在于实际工作簿的如何处理？）	13
选中某些表（按表名，按表对象）	13
4.查找	13
查找	13
SearchRange 按正则查找，按数值查找，按模糊查找。返回符合的range数组，包括合并单元格，是否是合并单元格，返回合并单元格所有信息，起始行列，合并的行列数	13
SearchCell，按正则查找，按数值查找，按模糊查找。返回符合的单元格数组，如果查找不到则返回空数组还是空？	13
SearchInRange，返回列号或者区域的相对序号	13
搜索field在表头的位置，相对列序号	13
搜索侧边field在单列表头的位置，相对行序号	13
MergedRange起始行列，占据行列数	14
该表是否存在某些特征的单元格（关键词数组，全符合，或者符合部分）	14
该表是否存在某些特征的连续几个单元格（关键词数组，全符合，或者符合部分，模糊匹配还是全匹配，大小写）	14
5.基于查找的处理	14
合并单元格解除并填充	14
符合条件的range或cell，填充数值或者清除	14
SearchRange多条件：相对位置的旁边单元格有其他标识(规定顺序，不规定顺序，上下，左右，矩阵)	14
union所有符合条件的结果range	14
union所有符合条件的结果cell	14
union所有符合条件的range所在的行或列	14
union所有符合条件的cell所在的行或列	14
替换	14
6.定位范围	14
最大行	14
最大列	14
第一行非空行号	14
第一列非空列号	14
/////自此可以获得一个区域，可能包含表头，可能包含侧表头，上下左右的非数据区域	14
7.定义一个数据区，设定表头行数，侧边field行数，获得实际数据区域，实际数据数组	15
行数	15
列数	15
实际数据行数	15
实际数据列数	15
取某列，按序号，按表头，带不带表头，带不带表尾，取到最后还是取到最后一行非空	15
取某行，按序号，按侧边表头，带不带表头，带不带表尾，取到最后还是取到最后一列非空	15
8.区域操纵	15
区域行列对调	15
WkSheetDelete表删除列	15
RangeDeleteBy    range删除相对列序号	15
9.数组操纵	16
数组按（行号数组）A.清空clear行（清空后行数不变），B.删除行（删除后数组行数变少）	16
C.替换	16
数组按（列号数组）A.清空clear行（清空后列数不变），B.删除delete行（删除后数组列数变少）	16
C.替换	16
按行或列序号数组，提取某数组形成新数组	16
数组按条件清空或者删除行列。条件：某行或某列的一个或多个字段符合某特征。	16
数据清洗	16
增删查改	16
数组中间，头，尾，增加行列（1.增加新数据 2.增加空行列）	16
复制一个一模一样的数组	16
数组维度	18
创建精简版（按功能拆解，需要调用更多外部函数）和完整版的函数	18
生成一个相同行列的空数组	18
生成一个比原来数组增加空行列的数组	19
向下和向左改变Array的尺寸	20
一维转二维（数据不变）	20
修改数组下限开始数字	20
按新序号生成新数组，新数组的列数行数大于等于旧数组，新数组的数据可能只获取旧数组的一部分列号或者行号	21
堆叠多个数组（垂直vstack，水平hstack）	21
切割数组	21
截取数组	21
去掉或截取最后几行，几列	21
数组处理，参考numpy和pandas框架	21
10.对数组进行统计	21
1.临时表里sql统计	21
2.常见统计：	21
按列，按行，按整个区域	21
最大，最小	21
取唯一	21
数组一对多查找，数组一对多展开，填充纵向	21
11.集合	21
12.字典	21
13.数据表range与数组	22
数组粘贴到数据表,返回信息字典，{error:errmsg,lastrow:xxx,}	22
range设定每个range行或列的数据格式，采用text的格式数组然后读取应用	22
工作表按格式字典（列号：text format）设定整列格式	22
区域先设定格式再粘贴数组 pasteArrOnRangeWithFormat(range,arr,formatArray)	22
vlookup和hlookup和index和match的应用	23
可能用得着的其他现成函数	23
分为process(处理)和信息info	25
单元格高级合并	25
纵向合并相同单元格	25
横向合并相同单元格	25
合并单元格并保留所有值（单元格里原来的每行用换行符换行）	25
纵向取消合并单元格并填充	25
横向取消合并单元格并填充	25
检查关键词列表(arr,或range)有多少存在于某个text（range）中，应用场景比如：表头检测，返回字符串，空，关键词逗号隔开的字符串	25
2.拆分	25
总数据key-value, 分数据key，需要填入vlaue。（形式：arr，dic，range）	26
svlookup	26
常规手动一系列操作自动化	26
批量将工作表转为独立工作簿	26
数据处理方便方法	26
常用对象在高级语言里有的特性，做vba化	26
5. 复制指定文件夹下多工作簿的工作表到汇总工作簿	26
常用代码封装：判断型isXXXX	27
‘拆分表格到多个表格	27
’拆分表格到多个文件（每个文件单一表格）	27
获取value的arr或rng，从不同方法获得：	27
规范的sheet，一行title	27
某range，n行title，N行左title，n行右title，n行底title	27
特殊:某range,n行title	27
某range,无title	27
'**************************工作簿	27
‘**************************工作表	27
‘**************************Range对象	28
‘**************************Chart对象	29
‘**************************Shape对象	29
‘**************************数据输入	29
'**************************菜单和工具栏	29
'**************************Ribbon功能区	29
'**************************控件	30
‘**************************'窗体	30
'**************************目录和文件操作	30
’‘**************************文件的输入输出	32
‘‘**************************数据库	32
’‘**************************Internet	32
‘‘**************************XML	32
’‘**************************数组与字典	32
集合转换到数组CollectionToArray	33
‘‘**************************代码优化与高效编程	33
‘‘**************************字符串	33
‘**************PDF打印	34
数组粘贴到range的左上角第一个单元格	36
'二维数组行数	36
'二维数组列数	36
’数组元素个数	36










代码框架，代码块
如：
检查表是否正确，一发现有不正确的就返回
function CheckSheet() as dictionary
ResultDic
'ResultDic的结构：StatusCode成功或失败的flag，失败信息
''ResultDic={“STATUS_CODE”:1 OR 0,”ERRORMSG”:””}
'
ResultDic(“STATUS_CODE”)=1

'1.检查第一点

 if 不通过 then
‘设置ResultDic
isError=true
ResultDic(“STATUS_CODE”)=0
ResultDic(“ERRORMSG”)=”something goes wrong”

Goto EndOfSub
endif
'2.检查第二点
‘XXXXXXXXXX


EndOfSub:
CheckSheet=ResultDic

end sub

'检查表格是否符合所有条件
CheckSheetAllConditions（）
{
'ResultDic的结构：StatusCode成功或失败的flag，失败信息
'ResultDic={“STATUS_CODE”:1 OR 0,”ERRORMSG”:””}

ifErrorHappen=false
errorMsgStr=””

‘开始检查
比如
所有应该有的字段是否存在，返回欠缺的字段？

1.第一个检查项目
If 通过 then

Else
ifErrorHappen=false
errorMsgStr=errorMsgStr+”<##>”+”item1 something goes wrong”
endif


‘填充返回结果
If ifErrorHappen then
ResultDic(“STATUS_CODE”)=1
ResultDic(“ERRORMSG”)=errorMsgStr
endif

CheckSheetAllConditions=ResultDic


}



检查常用手法

检查某顺序的几个（multiline）field是否存在于指定尺寸的range里，考不考虑field的顺序option
1.获得目标表格的最大列和行，确定表头范围
2.把表头range和原先应该有的array放入到该函数里，（array可以是一行也可以是多行，本质上是比较数组和range的value生成的数组是否匹配）
如果是多行，那么就只能固定顺序
如果是一行，那么可以顺序不固定，并且返回顺序是不是固定的判断结果
所以，可能可以作为两个函数
isMultilineFieldMatch(arrToDetect ,arrStandard ) 返回true false
isSingleLineFieldMatch(arrToDetect ,arrStandard ,needInOrder是否要求按照顺序) 返回true false


‘传入数组更有通用性
Function isMultilineFieldMatch(ByVal arrToDetect As Variant, ByVal arrStandard As Variant) As Boolean
    '判断参数是否为数组
    If Not IsArray(arrToDetect) Or Not IsArray(arrStandard) Then
    '检测到参数不为数组，程序停止
    Stop
    End If
    
    '1.先判断尺寸是否一致
    arrToDetectRowCount = UBound(arrToDetect, 1) - LBound(arrToDetect, 1) + 1
    arrToDetectColCount = UBound(arrToDetect, 2) - LBound(arrToDetect, 2) + 1
    
    arrStandardRowCount = UBound(arrStandard, 1) - LBound(arrStandard, 1) + 1
    arrStandardColCount = UBound(arrStandard, 2) - LBound(arrStandard, 2) + 1
    
    If arrToDetectRowCount <> arrStandardRowCount Or arrToDetectColCount <> arrStandardColCount Then
    '尺寸不匹配返回False
    isMultilineFieldMatch = False
    Exit Function
    End If
    
    arrStandardRowIndexOffset = LBound(arrStandard, 1) - LBound(arrToDetect, 1)
    arrStandardColIndexOffset = LBound(arrStandard, 2) - LBound(arrToDetect, 2)
    
    
    For i = LBound(arrToDetect, 1) To UBound(arrToDetect, 1)
        For j = LBound(arrToDetect, 2) To UBound(arrToDetect, 2)
        '一律用字符串比较。空单元也用空字符串比较。所以传入的arr参数，如果有空的单元格，应该变为""
            If arrToDetect(i, j) & "" <> arrStandard(i + arrStandardRowIndexOffset, j + arrStandardColIndexOffset) & "" Then
            '发现有不一样的地方
                isMultilineFieldMatch = False
                Exit Function
            End If
        Next j
    Next i
    
    isMultilineFieldMatch = True
End Function


对数组所有元素进行lcase和ucase设置
ArrayLcase(arr)
ArrayUcase(arr)


检查某顺序的几个field是否存在于某range里或某相同排列的arr里，考不考虑field的顺序option


按某range的几个列号（绝对，相对）组成新数组
CreateArrayFromRange

、、
Sub aaa()
arr = CreateArrayFromRange(Range("a2:h5"), Array(1, 3, 5), 3)


End Sub
//TODO
Function CreateArrayFromRange(ByVal rng As Range, ByVal colArr As Variant, ByVal baseNum As Long)

srcArr = rng.Value
'判断是否是数组

'判断是否是一维数组
'相对于range的列号

'计算colArr元素个数
colCount = UBound(colArr) - LBound(colArr) + 1

indexOffset = baseNum - LBound(srcArr)



srcArrRowCount = UBound(srcArr, 1) - LBound(srcArr, 1) + 1

srcArrColCount = UBound(srcArr, 2) - LBound(srcArr, 2) + 1
'创建新数组
Dim resultArr() As Variant
ReDim resultArr(baseNum To baseNum + srcArrRowCount - 1, baseNum To baseNum + colCount - 1)
For i = LBound(srcArr) To UBound(srcArr)
    
    resultColIndex = baseNum
    For j = LBound(colArr) To UBound(colArr)
        resultArr(i, resultColIndex) = srcArr(i, colArr(j))
        resultColIndex = resultColIndex + 1
    Next j

Next i


CreateArrayFromRange = resultArr

'相对于sheet的列号




End Function




基于某base计算出现有数组修改下限开始数字后该有的上限
GetShapeByNewBaseNum
base to base+count-1
newBase to newBase+count-1
'二维
Function GetShapeByNewBaseNum(ByVal arr As Variant, ByVal newBaseNum As Long)
    arrRowCount = UBound(arr, 1) - LBound(arr, 1) + 1
    arrColCount = UBound(arr, 1) - LBound(arr, 1) + 1
    GetShapeByNewBaseNum = Array(newBaseNum, newBaseNum + arrRowCount - 1, newBaseNum + arrColCount - 1)
End Function

数组转集合
'================================
' VBA数组转换到集合ArrayToCollection
'
' http://www.cnhup.com
'================================
 
Public Function ArrayToCollection( _
  Arr As Variant, ByRef Coll As Collection) _
  As Boolean
Dim Ndx As Long
Dim KeyVal As String
 
If IsArray(Arr) = False Then
    ArrayToCollection = False
    Exit Function
End If
 
On Error GoTo ErrH:
Select Case NumberOfArrayDimensions(Arr:=Arr)
    Case 0
        ArrayToCollection = False
        Exit Function
        
    Case 1
        For Ndx = LBound(Arr) To UBound(Arr)
            Coll.Add Item:=Arr(Ndx)
        Next Ndx
    
    Case 2
        For Ndx = LBound(Arr, 1) To UBound(Arr, 1)
            KeyVal = Arr(Ndx, 1)
            If Trim(KeyVal) = vbNullString Then
                Coll.Add Item:=Arr(Ndx, 1)
            Else
                Coll.Add Item:=Arr(Ndx, 0), Key:=KeyVal
            End If
        Next Ndx
    
    Case Else
        ArrayToCollection = False
        Exit Function
 
End Select
 
ArrayToCollection = True
Exit Function
 
ErrH:
    ArrayToCollection = False
 
End Function

集合转数组
'================================
' VBA集合转换到数组CollectionToArray
'
' http://www.cnhup.com
'================================
 
Public Function CollectionToArray( _
  Coll As Collection, Arr As Variant) _
  As Boolean
Dim V As Variant
Dim Ndx As Long
 
If Coll Is Nothing Then
    CollectionToArray = False
    Exit Function
End If
 
If IsArray(Arr) = False Then
    CollectionToArray = False
    Exit Function
End If
If IsArrayDynamic(Arr:=Arr) = False Then
    CollectionToArray = False
    Exit Function
End If
 
If Coll.Count < 1 Then
    CollectionToArray = False
    Exit Function
End If
    
ReDim Arr(1 To Coll.Count)
 
For Ndx = 1 To Coll.Count
    If IsObject(Coll(Ndx)) = True Then
        Set Arr(Ndx) = Coll(Ndx)
    Else
        Arr(Ndx) = Coll(Ndx)
    End If
Next Ndx
 
CollectionToArray = True
 
End Function


集合对比



单行单列数组对比
检查两组元素数组，对比
步骤：
1.检查数组是不是单列或者单行
2.检查每个数组是否有重复项（是否唯一），根据CompareMode ，两种模式，文本（不区分文本大小）和二进制（区分文本大小写）
3.检查每个数组如果算重复项有多少count，去重后有多少count
4.如果两列数组方向一致，数组个数一致，则比较是否完全一致
5.如果如果两列数组方向一致，数组个数一致，且各自都没有重复项，输出数组A在数组B里的index，以key-value的方式输出
输出字典
数组1元素个数
数组2元素个数
数组1和数组2元素个数差异
数组1与数组2共同元素数组
数组1比数组2多的元素数组
数组1比数组2少的元素数组



参考
CompareMode 属性包含以下部分：
语法
Part	说明
object	必填。 始终为 Dictionary 对象的名称。
compare	可选。 如果提供 ，compare 是表示 StrComp 等函数所使用的比较模式的值。

compare 参数可以包含以下值：
设置
常量	值	说明
vbUseCompareOption	-1	使用 Option Compare 语句的设置来执行比较。
vbBinaryCompare	0	执行二进制比较。
vbTextCompare	1	执行文本比较。
vbDatabaseCompare	2	仅用于 Microsoft Access。 根据数据库中的信息执行比较。



获得数组唯一值数组,三种比较模式，参考字典
UniqueArray()



CompareSingleDimentionArray检查字段是否缺失，缺失了哪些，多出了哪些，横向，纵向
数组元素应不应该唯一
返回一份报告字典
0.检查数组元素是否唯一
1.检查数目是否准确
2.如果数目准确，按提供的字段和原来应该要有的字段两份结论string，分别指出多余的和空缺的
3.如果匹配，可以用其他函数获取字段的index，行或者是列的序号（相对序号和绝对行列号）
输入参数:两个数组
字典结构：
数组1元素个数
数组2元素个数
数组1和数组2元素个数差异
数组1与数组2共同元素数组
数组1比数组2多的元素数组
数组1比数组2少的元素数组
如果数组元素完全一样只是顺序不同，那么输出数组1key-value(在数组2的index，1下限)


数组某列变为某种数据类型，比如数字变为字符串，或字符串变为数字，字符串全部大写，字符串全部小写
GetArrayWithDataTypeChanged(byval arr as variant,byval col as long)


比较两个数组的size（shape）
CompareArrayShape(byval arr1 as variant ,byval arr2 as variant)

生成空数组
Function CreateEmptyArray(ByVal rowCount As Long, ByVal colCount As Long, Optional baseNum As Variant)
'创建新数组
    Dim resultArr() As Variant
    ReDim resultArr(baseNum To baseNum + rowCount - 1, baseNum To baseNum + colCount - 1)
    CreateEmptyArray = resultArr
End Function
提供两个数组，获得第一个数组的元素相对于第二个数组的绝对序号
前提:两个数组都唯一


提供一个数组和一个range，获得第一个数组的元素相对于range的表格列号和相对数组的列号




获得某个横向或者纵向的单行或单列的field-row 或field-col的   rowindex或colIndex的字典







合并单元格的field如何检查（数组匹配）

自创数组类似sql筛选的体系

自创数组类似表格排序的体系
func(arr,)
   
常规场景操作自动化
1.汇总框架
涉及到：
1.文件夹
文件夹是否存在
文件是否存在
文件夹不存在则创建CreateDir()
获取文件夹下文件列表
获取文件夹下某些文件格式列表
获取文件夹下子文件夹列表
获取文件夹和子文件夹下所有文件列表
获取文件夹和子文件夹下的某些文件格式列表
删除文件夹下文件-按文件列表删
删除文件夹下文件-按某些文件格式删
清空文件夹(删除再新建)
2.文件
文件路径
文件格式名
文件名称
文件短名带格式名
文件其他信息
3.
某表名表格是否存在
某些表名是否存在
提供表名数组，返回存在于工作簿的表名(实质是提供数组A和数组B，返回A存在于数组B的结果)
提供表名数组，返回不存在于工作簿的表名(实质是提供数组A和数组B，返回A不存在于数组B的结果)
数组元素相减（集合相减）？交集？
二维数组转一维
按列拼接，按行拼接

多行多列数组转单行单列数组

按表名数组创建新表（已存在的如何处理？）
按表名数组删除表（不存在的表名是否报错？）
表格位置排序
删除所有表除了某表名
删除所有表除了某表
删除所有表除了数组里的表名
删除所有表除了数组里的表（数组里不存在于实际工作簿的如何处理？）
选中某些表（按表名，按表对象）
4.查找
查找
SearchRange 按正则查找，按数值查找，按模糊查找。返回符合的range数组，包括合并单元格，是否是合并单元格，返回合并单元格所有信息，起始行列，合并的行列数
SearchCell，按正则查找，按数值查找，按模糊查找。返回符合的单元格数组，如果查找不到则返回空数组还是空？
SearchInRange，返回列号或者区域的相对序号
搜索field在表头的位置，相对列序号
搜索侧边field在单列表头的位置，相对行序号

MergedRange起始行列，占据行列数
该表是否存在某些特征的单元格（关键词数组，全符合，或者符合部分）
该表是否存在某些特征的连续几个单元格（关键词数组，全符合，或者符合部分，模糊匹配还是全匹配，大小写）
5.基于查找的处理
合并单元格解除并填充
符合条件的range或cell，填充数值或者清除
SearchRange多条件：相对位置的旁边单元格有其他标识(规定顺序，不规定顺序，上下，左右，矩阵)
union所有符合条件的结果range
union所有符合条件的结果cell
union所有符合条件的range所在的行或列
union所有符合条件的cell所在的行或列
替换
6.定位范围
最大行
Function GetLastRow(ByVal sht As Worksheet, ByVal col As Variant)
    GetLastRow = sht.Cells(Rows.Count, col).End(3).row
End Function

最大列
Function GetLastColumn(ByVal sht As Worksheet, ByVal row As Variant)
    GetLastColumn = sht.Cells(row, Columns.Count).End(3).row
End Function

第一行非空行号
第一列非空列号
/////自此可以获得一个区域，可能包含表头，可能包含侧表头，上下左右的非数据区域
7.定义一个数据区，设定表头行数，侧边field行数，获得实际数据区域，实际数据数组
行数
列数
实际数据行数
实际数据列数
取某列，按序号，按表头，带不带表头，带不带表尾，取到最后还是取到最后一行非空
取某行，按序号，按侧边表头，带不带表头，带不带表尾，取到最后还是取到最后一列非空




8.区域操纵
区域行列对调
WkSheetDelete表删除列
RangeDeleteBy    range删除相对列序号

9.数组操纵
数组按（行号数组）A.清空clear行（清空后行数不变），B.删除行（删除后数组行数变少）
C.替换
数组按（列号数组）A.清空clear行（清空后列数不变），B.删除delete行（删除后数组列数变少）
C.替换
按行或列序号数组，提取某数组形成新数组

数组按条件清空或者删除行列。条件：某行或某列的一个或多个字段符合某特征。

数据清洗

增删查改
数组中间，头，尾，增加行列（1.增加新数据 2.增加空行列）

复制一个一模一样的数组
‘深度复制，可以设置lboundBase 下限开始数字，函数内依赖其他函数计算数组维度，如果想要跟参数数组下标下限一致，那么传入lbound(原数组)作为参数
Function DeepCopyArray(ByVal arr As Variant, Optional lboundBase As Variant) As Variant


    If IsArray(arr) = False Then
        '检测到非数组参数
        Stop
        End
    End If
    
    If IsMissing(lboundBase) Then
        lboundBase = LBound(arr)
    End If
    
    Dim tmpArr() As Variant
    arrDimention = nDim(arr)
    '一维
    If arrDimention = 1 Then
        tmpArrCount = 0
        '计算一维数组元素个数
        arrCount = UBound(arr, 1) - LBound(arr, 1) + 1
        ReDim tmpArr(lboundBase To lboundBase + arrCount - 1)
        '计算下标差异偏移
        indexOffset = UBound(tmpArr, 1) - UBound(arr, 1)
         
        For i = LBound(arr, 1) To UBound(arr, 1)
            tmpArr(i + indexOffset) = arr(i)
        Next i
        DeepCopyArray = tmpArr
        Exit Function
    End If
    
    '二维
    If arrDimention = 2 Then
        
        tmpArrRowCount = 0
        tmpArrColCount = 0
        '计算数组行元素个数
        arrRowCount = UBound(arr, 1) - LBound(arr, 1) + 1
        arrColCount = UBound(arr, 2) - LBound(arr, 2) + 1
        ReDim tmpArr(lboundBase To lboundBase + arrRowCount - 1, lboundBase To lboundBase + arrColCount - 1)
        '计算下标差异偏移
        rowIndexOffset = UBound(tmpArr, 1) - UBound(arr, 1)
        colIndexOffset = UBound(tmpArr, 2) - UBound(arr, 2)
        For i = LBound(arr, 1) To UBound(arr, 1)
            For j = LBound(arr, 2) To UBound(arr, 2)
                tmpArr(i + rowIndexOffset, j + colIndexOffset) = arr(i, j)
            Next j
        Next i
        DeepCopyArray = tmpArr
        Exit Function
    End If
    
    If arrDimention > 2 Then
    '不支持大于2维度的数组
    Stop
    End
    End If
   
End Function


让有数据的数组像粘贴到range左上角第一个单元格一样粘贴到另一个数组里


数组维度
黄色底色代表网摘验证通过
Private Function nDim(ByVal vArray As Variant) As Long
' Purpose: get array dimension (MS)
Dim dimnum     As Long
Dim ErrorCheck As Long    ' OP: As Variant
On Error GoTo FinalDimension

For dimnum = 1 To 60000    ' 60000 being the absolute dimensions limitation
    ErrorCheck = LBound(vArray, dimnum)
Next
' It's good use to formally exit a procedure before error handling
' (though theoretically this wouldn't needed in this special case - see comment)
Exit Function

FinalDimension:
nDim = dimnum - 1

End Function


创建精简版（按功能拆解，需要调用更多外部函数）和完整版的函数

生成一个相同行列的空数组
如果想要跟参数数组下标下限一致，那么传入lbound(原数组)作为参数

生成一个比原来数组增加空行列的数组
上下左右（中间），增加N行或列
Function CreateaExpandArray(ByVal arr As Variant, ByVal addTopCount As Long, ByVal addBottomCount As Long, ByVal addLeftCount As Long, ByVal addRightCount As Long)
    addVerticalCount = addTopCount + addBottomCount
    addHorizonCount = addLeftCount + addRightCount
    
    If IsArray(arr) = False Then
        '检测到非数组参数
        Stop
        End
    End If
    
    arrDimention = nDim(arr)
    
    '一维
    If arrDimention = 1 Then
        '提示先用函数转换为二维
        Stop
        End
    
    End If
    
    
    '二维
    If arrDimention = 2 Then

        '计算数组行列元素个数
        arrRowCount = UBound(arr, 1) - LBound(arr, 1) + 1
        arrColCount = UBound(arr, 2) - LBound(arr, 2) + 1
        
        Dim resultArr() As Variant
        ReDim resultArr(LBound(arr, 1) To UBound(arr, 1) + addVerticalCount, LBound(arr, 2) To UBound(arr, 2) + addHorizonCount)
        
        '把数据源数组粘贴到新数组
        For i = LBound(arr, 1) To UBound(arr, 1)
            For j = LBound(arr, 2) To UBound(arr, 2)
                resultArr(i + addTopCount, j + addLeftCount) = arr(i, j)
            Next j
        Next i
        CreateaExpandArray = resultArr
        Exit Function
    End If
    
    If arrDimention > 2 Then
    '不支持大于2维度的数组
    Stop
    End
    End If
End Function

提供一个数组A，选定某列作为key，选择另一个区域或数组B，选定列作为key，选择B的某列填充到数组A

提供一个区域A，选定某列作为key，选择另一个区域或数组B，选定列作为key，选择B的某列填充到区域A



向下和向右改变Array的尺寸
ResizeArray，也就是Redim Preserve
Function ResizeArray(ByVal arr As Variant, ByVal newRow As Long, ByVal newCol As Long)

'TODO判断维度

'判断新行列数是否比原有的小
'二维
    arrRowCount = UBound(arr, 1) - LBound(arr, 1) + 1
    arrColCount = UBound(arr, 2) - LBound(arr, 2) + 1
    
    Dim resultArr() As Variant
    ReDim resultArr(LBound(arr, 1) To LBound(arr, 1) + newRow - 1, LBound(arr, 2) To LBound(arr, 2) + newCol - 1)
    '此处用粘贴数组到数组或者重新写粘贴代码
    For i = LBound(arr, 1) To UBound(arr, 1)
        For j = LBound(arr, 2) To UBound(arr, 2)
            resultArr(i, j) = arr(i, j)
            
        Next j
    
    Next i
    
    ResizeArray = resultArr
End Function

一维转二维（数据不变）
Function Arr1DTo2D(arr)
    If IsArray(arr) = False Then
        '检测到非数组参数
        Stop
    End
    End If
    '获得维度
    arrDimention = nDim(arr)
    If arrDimention > 1 Then
        '数组维数大于1，规定只能是1
        Stop
        End
        
    End If
    Dim resultArr() As Variant
    ReDim resultArr(LBound(arr) To LBound(arr), LBound(arr) To UBound(arr))
    
    For i = LBound(arr) To UBound(arr)
        resultArr(LBound(arr), i) = arr(i)
    Next i
    Arr1DTo2D = resultArr
End Function

只有一行的二维转一维
‘还没完成
Function SingleLineArr2DTo1D(ByVal arr As Variant, Optional baseNum As Variant)
'判断为维度

If nDim(arr) <> 2 Then
    '检测到参数非二维数组
    Stop
    End
End If

'判断是否是单行
If UBound(arr, 1) <> LBound(arr, 1) Then
    '检测到参数非单行数组
    Stop
    End
End If

If IsMissing(baseNum) Then
baseNum = 0
End If
Dim resultArr() As Variant
ReDim resultArr(baseNum To baseNum + UBound(arr, 2) - LBound(arr, 2))
'数组粘贴到数组
'/////TODO


SingleLineArr2DTo1D = resultArr
End Function

修改数组下限开始数字

按新序号生成新数组，新数组的列数行数大于等于旧数组，新数组的数据可能只获取旧数组的一部分列号或者行号
FillInArr(newArr,srcArr,fromToDict={srcColIndex:newArrsrcColIndexIndex,xxxxxx})

堆叠多个数组（垂直vstack，水平hstack）
Function ArrayVStack(ByVal arr1 As Variant, ByVal arr2 As Variant, ByVal baseNum As Long)
    '判断是否是数组
    '判断数组维度
    '一维的话要不要转为二维还是弹出提示
      
  '检查两个数组的行数列数各自的下限数字是否一致
‘todo
    '以下是二维数组的处理
    arr1_RowCount = UBound(arr1, 1) - LBound(arr1, 1) + 1
    arr1_ColCount = UBound(arr1, 2) - LBound(arr1, 2) + 1
    arr2_RowCount = UBound(arr2, 1) - LBound(arr2, 1) + 1
    arr2_ColCount = UBound(arr2, 2) - LBound(arr2, 2) + 1
    '判断两个数组的列数是否一致，不一致退出
    If arr1_ColCount <> arr2_ColCount Then
        '两个数组列数不一致，程序停止
        Stop
        End
    End If
    '如果两个数组列数一致
    Dim resultArr() As Variant
    indexOffset = baseNum - LBound(arr1, 1)
    ReDim resultArr(baseNum To baseNum + arr1_RowCount + arr2_RowCount - 1, baseNum To baseNum + arr1_ColCount - 1)
    '复制arr1
    For i = LBound(arr1, 1) To UBound(arr1, 1)
        For j = LBound(arr1, 2) To UBound(arr1, 2)
            resultArr(i + indexOffset, j + indexOffset) = arr1(i, j)

        Next j
    Next i
    '复制arr2
    For i = LBound(arr2, 1) To UBound(arr2, 1)
        For j = LBound(arr1, 2) To UBound(arr1, 2)
            resultArr(i + arr1_RowCount + indexOffset, j + indexOffset) = arr2(i, j)
        Next j
    Next i
    ArrayVStack = resultArr
End Function

创建一个函数，用来获得新base与旧函数的对应关系

切割数组
截取数组
去掉或截取最后几行，几列

数组处理，参考numpy和pandas框架

10.对数组进行统计
1.临时表里sql统计
2.常见统计：
按列，按行，按整个区域
最大，最小
取唯一

数组一对多查找，数组一对多展开，填充纵向


11.集合

12.字典


13.数据表range与数组
数组粘贴到数据表,返回信息字典，{error:errmsg,lastrow:xxx,}

range设定每个range行或列的数据格式，采用text的格式数组然后读取应用
考虑列序号，连续列的设置，用字符串当做参数，还是数组
先做最繁琐的，然后做简便的作为衍生函数
各自列有各自的格式
创建枚举
Private Enum ColumnIndexMode
RelativeInRange = 0
SheetColumnNumber= 1
SheetColumnLetter=2
End Enum

Enum
相对列号模式（1开始）
表格绝对列号数字模式
表格绝对列号字母模式



‘数组作为参数
SetRangeColumnNumberFormat(Column模式, 相对列号数组/表列号数字数组/列号字母数组/列号数字字母混合数组，格式数组)
‘字符串作为参数（可以便捷填写连续的位置）
- 衍生 SetRangeColumnNumberFormat(Column模式, 按自定义格式写字符串，格式数组)




SetSheetColumnNumberFormat(byval sht as worksheet,byval colArr as variant,a)

多个列数组或字符串，应用同一种格式


工作表按格式字典（列号：text format）设定整列格式

区域先设定格式再粘贴数组 pasteArrOnRangeWithFormat(range,arr,formatArray)


设置整个表的整列和单元格格式的字典
SetSheetColumnFormat(col:format 字典)
‘TODO
Sub SetSheetMultiColumnFormat(ByVal col_format_dic As Dictionary)
    
    '数字列号统一换成字母
    
    
    if typeOF(A)
    
    '获得列号字母
    Replace(Cells(1, num).Address(False, False), "1", "")
    Range("H:H").NumberFormatLocal = "@"

End Sub

设置区域的列和单元格格式的字典

设置整个表的多列，应用相同的单元格格式

设置区域的多列，应用相同的单元格格式



复制字典的代码块（用来遍历修改key的格式，字符串...生成新字典）


粘贴数组到某单元格开始的区域，返回边界粘贴后的边界array(左上角单元格行，列，右下角单元格行，列)
Function PasteArrayAtCell(ByVal arr As Variant, ByVal cel As Range) As Variant '返回边界粘贴后的边界array(左上角单元格行，列，右下角单元格行，列)
    '判断arr是不是数组
    If Not IsArray(arr) Then
    'arr不是数组
        Stop
        End
    End If
    'TODO
    '判断arr维度
    If nDim(arr) <> 2 Then
        'arr维数不是2
        Stop
        End
    End If
    arr_rowCount = UBound(arr, 1) - LBound(arr, 1) + 1
    arr_colCount = UBound(arr, 2) - LBound(arr, 2) + 1
    cel.Resize(arr_rowCount, arr_colCount) = arr
    PasteArrayAtCell = Array(cel.row, cel.Column, cel.row + arr_rowCount - 1, cel.Column + arr_colCount - 1)
End Function

vlookup和hlookup和index和match的应用




可能用得着的其他现成函数





分为process(处理)和信息info



单元格高级合并
纵向合并相同单元格
横向合并相同单元格
合并单元格并保留所有值（单元格里原来的每行用换行符换行）
纵向取消合并单元格并填充
横向取消合并单元格并填充



检查关键词列表(arr,或range)有多少存在于某个text（range）中，应用场景比如：表头检测，返回字符串，空，关键词逗号隔开的字符串

2.拆分





总数据key-value, 分数据key，需要填入vlaue。（形式：arr，dic，range）
svlookup


常规手动一系列操作自动化
批量将工作表转为独立工作簿
Sub Newbooks()    'EH技术论坛。VBA编程学习与实践。看见星光    Dim sht As Worksheet, mypath$    With Application.FileDialog(msoFileDialogFolderPicker)   '选择保存工作薄的文件路径        .AllowMultiSelect = False        '不允许多选        If .Show Then            mypath = .SelectedItems(1)            '读取选择的文件路径        Else            Exit Sub            '如果没有选择保存路径，则退出程序        End If    End With    If Right(mypath, 1) <> "\" Then mypath = mypath & "\"    Application.DisplayAlerts = False    '取消显示系统警告和消息，避免重名工作簿无法保存。当有重名工作簿时，会直接覆盖保存。    Application.ScreenUpdating = False    '取消屏幕刷新    For Each sht In Worksheets    '遍历工作表        sht.Copy        '复制工作表，工作表单纯复制后，会成为活动工作薄        With ActiveWorkbook            .SaveAs mypath & sht.Name, xlWorkbookDefault            '保存活动工作薄到指定路径下，以默认文件格式            .Close True '关闭工作薄并保存        End With    Next    MsgBox "处理完成。", , "提醒"    Application.ScreenUpdating = True '恢复屏幕刷新    Application.DisplayAlerts = True '恢复显示系统警告和消息End Sub



数据处理方便方法

常用对象在高级语言里有的特性，做vba化
5. 复制指定文件夹下多工作簿的工作表到汇总工作簿


常用代码封装：判断型isXXXX
系统自带：
isArray
自定义：
isXXX


‘拆分表格到多个表格

’拆分表格到多个文件（每个文件单一表格）


获取value的arr或rng，从不同方法获得：
规范的sheet，一行title
某range，n行title，N行左title，n行右title，n行底title
特殊:某range,n行title
某range,无title




'**************************工作簿
WbCreateSheet(wb,location,shtName)
'ws1 = wb.create_sheet() --> 默认插在工作簿末尾
'ws2 = wb.create_sheet(0) --> 插入在工作簿的第一个位置

WbCreateSheets(Array)

ArrSheetsNameInWb(wb)  '只获取表名，不获取表对象

‘**************************工作表
max_column(sht,rowIndex)
max_row(sht,"a")

ws.merge_cells("A1:B1")
ws.merge_cells(start_column=3,end_column=6,start_row=2,end_row=3)
ws.merged_cells



ws.append()'openpyxl的给表添加行数据的方法

'@功能:工作簿是否存在某表名的工作表
'@返回值：true false
Function IsSheetExist(ByVal wb As Workbook, ByVal shtname As String)
    Dim d
    Set d = CreateObject("Scripting.Dictionary")
    For Each sh In wb.Sheets
       d(sh.Name) = ""
    Next
    If d.exists(shtname) Then
         IsSheetExist= True
    Else
        IsSheetExist= False
    End If
    Set d = Nothing
End Function

‘**************************Range对象
‘列号转字母
Function ColumnIntIndexToLetters(ByVal num As Long) As String
    ColumnIntIndexToLetters = Replace(Cells(1, num).Address(False, False), "1", "")
End Function
‘字母转列号
Function ColumnLettersToIntIndex(ByVal AB As String) As Long
    ColumnLettersToIntIndex = Range("a1:" & AB & "1").Cells.Count
End Function


addHyperlink(path,title)



getRng(startRow,endRow,startCol,endCol)'返回区域
getRowDataFromArr
getRowDataFromRng
getColumnDataFromArr
getColumnDataFromRng


操作
插入行
插入列
插入多行
插入多列

===================================
1 Range.SpecialCells() 
1.1 常用用法
可以非常快速的定位目标单元格
局限性：通用性很强
常用的
定位空单元格   range().specialcells(xlcelltypeblank)
定位最后1个单元格  range().specialcells(xlcelltypelastcell)
非常好，用处很大
实测这个是定位的整个sheet的所有usedrange 的右下角单元格
如果单元格为空但是被设置了格式比如颜色，那么usedrange会包含该单元格，但是end(xlup)会忽略该单元格找到有实际数据的单元格
 

另外一个好用的，定位出错单元格
Range("a1:c20").SpecialCells(xlCellTypeFormulas, 16)
===================================

‘**************************Chart对象

‘**************************Shape对象

‘**************************数据输入

'**************************菜单和工具栏

'**************************Ribbon功能区

'**************************控件

‘**************************'窗体

'**************************目录和文件操作
'@功能:判断文件夹或者文件是否存在
'@AUTHOR: 
'@DIM:
'@EXAMPLE: 
'@注意：strPathName="C:\abcd"和“C:\abcd\”都可以
Function IsPathExists(ByVal strPath As String) As Boolean
    If Dir(strPath, 16) <> Empty Then
        IsPathExists= True
    Else
        IsPathExists= False
    End If
End Function

'@功能:获取某文件夹下的文件列表，可用字符串过滤
'@AUTHOR: 
'@DIM:
'@EXAMPLE: 
'@注意：只返回文件，不返回子文件夹。
'@返回值：返回""或者返回数组
 Function GetFileList(ByVal strDirPath As String, Optional strFilter As String) As Variant
' 将文件列表放到数组
    Dim f As String
    Dim i As Long
    Dim FileList() As String

    If strFilter = "" Then strFilter = "*.*"
        Select Case Right(strDirPath , 1)
            Case "", "/"
            strPath = Left(strPath, Len(strDirPath ) - 1)
    End Select

    ReDim Preserve FileList(0)
    f = Dir(strDirPath & "/" & strFilter)
    Do While Len(f) > 0
       ReDim Preserve FileList(i) As String
       FileList(i) = f
       i = i + 1
       f = Dir()
    Loop
    If FileList(0) <> Empty Then
       GetFileList= FileList
    Else
       GetFileList= ""
    End If
End Function

TODO
'@功能:获取某文件夹下的文件列表，可用array过滤格式名






'@功能：判断文件夹是否存在，不存在则创建
Sub CheckAndCreateDir(byval dirPath as string)
 if IsPathExists(dirPath )=false then

else
MkDir dirPath 
endif

end sub

'@功能：'删掉文件夹再创建
FSO.GetFolder(pathG).Delete
MkDir pathG


'通过文件路径获取文件名
Function GetFileName(strFilePath As String) As String
    Dim strFileName As String
    GetFileName = ""
    If InStr(1, strFilePath, "\") > 0 Then
        strFileName = Split(strFilePath, "\")(UBound(Split(strFilePath, "\")))
        GetFileName = strFileName
    ElseIf InStr(1, strFilePath, "/") > 0 Then
        strFileName = Split(strFilePath, "/")(UBound(Split(strFilePath, "/")))
        GetFileName = strFileName
    End If
End Function


’弹窗选择文件夹


‘弹窗选择单个文件


’弹窗选择多个文件


’‘**************************文件的输入输出


‘‘**************************数据库


’‘**************************Internet


‘‘**************************XML



’‘**************************数组与字典
数组countUnique
https://github.com/x-vba/xlib/blob/master/Modules/xlibArray.bas


数组排序（下面这个代码会多一个空值，数组多一个element）
https://github.com/x-vba/xlib/blob/master/Modules/xlibArray.bas

数组反转
https://github.com/x-vba/xlib/blob/master/Modules/xlibArray.bas



append
indexOf
数组元素个数count，length

数组深度复制copy


集合转换到数组CollectionToArray
VBA数组转换到集合ArrayToCollection

‘‘**************************代码优化与高效编程




‘‘**************************字符串
'@功能:获取去除空格，tab和clean掉不可见字符的字符串
Function GetCleanString(ByVal theStr As String)
    theStr = Replace(theStr, Chr(10), "")
    theStr = Replace(theStr, Chr(13), "")
    theStr = Trim(theStr)
    theStr = Application.WorksheetFunction.Clean(theStr)
    GetCleanString = theStr
End Function


'@功能:根据文件完整路径获取文件名但不包括扩展名（如果文件路径是反向斜杠如何？）
Public Function GetFileNameOfNoExt(ByVal FilePathFileName As String) As String
    On Error Resume Next
    Dim i As Integer, J As Integer, k As Integer
    i = Len(FilePathFileName)
    J = InStrRev(FilePathFileName, "\")
    k = InStrRev(FilePathFileName, ".")
     If k = 0 Then
       GetFileNameOfNoExt= Mid(FilePathFileName, J + 1, i - J)
    Else
      GetFileNameOfNoExt= Mid(FilePathFileName, J + 1, k - J - 1)
    End If
End Function

'截取两字符串中间部分
Public Function GetStringBetweenAandB(ByVal originString As String, ByVal stringA As String, ByVal stringB As String, ByVal isIncludingA As Boolean, ByVal isincludingB As Boolean)
      GetStringBetweenAandB= strBeforeA(strAfterA(originString, stringA, isIncludingA), stringB, isincludingB)
End Function

'某字符串前
Public Function StrBeforeA(ByVal originString As String, ByVal targetAString As String, ByVal isIncludingTargetString As Boolean)
    If InStr(originString, targetAString) = 0 Then
        strBeforeA = ""
        Exit Function
    End If
    If isIncludingTargetString Then
        result = Left(originString, InStr(originString, targetAString) - 1)
        result = result + targetAString
    Else
        result = Left(originString, InStr(originString, targetAString) - 1)
    End If
    strBeforeA = result
End Function

'某字符串后
Public Function StrAfterA(ByVal originString As String, ByVal targetAString As String, ByVal isIncludingTargetString As Boolean)
    If InStr(originString, targetAString) = 0 Then
        strAfterA = ""
        Exit Function
    End If
    If isIncludingTargetString Then
        result = Right(originString, Len(originString) - InStr(originString, targetAString) + 1)
    Else
        result = Right(originString, Len(originString) - InStr(originString, targetAString) - Len(targetAString) + 1)
    End If
    strAfterA = result
End Function


‘**************PDF打印

’=============PDF打印开始
’第一步，对表格设置打印设置，每个表格分别设置，可以遍历
Sub PrintSetting(ByVal sht As Worksheet)

    Application.PrintCommunication = False
    With sht.PageSetup
        .PrintTitleRows = ""
        .PrintTitleColumns = ""
    End With
    Application.PrintCommunication = True
    ActiveSheet.PageSetup.PrintArea = ""
    Application.PrintCommunication = False
    With sht.PageSetup
        .LeftHeader = ""
        .CenterHeader = ""
        .RightHeader = ""
        .LeftFooter = ""
        .CenterFooter = ""
        .RightFooter = ""
        .LeftMargin = Application.InchesToPoints(0.7)
        .RightMargin = Application.InchesToPoints(0.7)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .PrintQuality = 600
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlPortrait
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = 1
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = ""
        .EvenPage.CenterHeader.Text = ""
        .EvenPage.RightHeader.Text = ""
        .EvenPage.LeftFooter.Text = ""
        .EvenPage.CenterFooter.Text = ""
        .EvenPage.RightFooter.Text = ""
        .FirstPage.LeftHeader.Text = ""
        .FirstPage.CenterHeader.Text = ""
        .FirstPage.RightHeader.Text = ""
        .FirstPage.LeftFooter.Text = ""
        .FirstPage.CenterFooter.Text = ""
        .FirstPage.RightFooter.Text = ""
    End With
    Application.PrintCommunication = True
    'ActiveWorkbook.PrintOut Copies:=1, Collate:=True, IgnorePrintAreas:=False

End Sub

‘第二步，打印
        tmpwb.ExportAsFixedFormat Type:=xlTypePDF, Filename:= _
        outputPath + "\" + "xxx" + ".pdf", Quality:= _
        xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, _
        OpenAfterPublish:=False


‘=============PDF打印结束

<===================================>
数组粘贴到range的左上角第一个单元格


'二维数组
'二维数组行数
Function Get2DArrayRowCount(ByVal theArray As Variant)
Get2DArrayRowCount = UBound(theArray, 1) - LBound(theArray, 1) + 1
End Function
'二维数组列数
Function Get2DArrayColumnCount(ByVal theArray As Variant)
Get2DArrayColumnCount = UBound(theArray, 2) - LBound(theArray, 2) + 1
End Function

’数组元素个数




